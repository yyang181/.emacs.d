#!Usr/bin/python3

import sys
sys.path.append("../")
import os

import numpy as np
import matplotlib.pyplot as plt
import platform
if platform.system() == "Linux":
    plt.switch_backend("agg")
import tensorflow as tf
config = tf.ConfigProto()
config.gpu_options.allow_growth = True
sess = tf.Session(config=config)
from mrcnn.config import Config
from mrcnn import model_mask
from skimage import io
from mrcnn.utils import rois_image
from mrcnn.simply_visualize import display_X
import argparse


# 病猪特征识别 mask 检测模型参数
class InferenceMaskConfig(Config):
    NAME = 'pig'
    NUM_CLASSES = 1 + 1
    IMAGES_PER_GPU = 1
    DETECTION_NMS_THRESHOLD = .3
    DETECTION_MIN_CONFIDENCE = .7

# 病猪特征识别 多分类 模型参数
class InferenceClsConfig(Config):
    IMAGES_PER_GPU = 1
    CLASSIFIER_INPUT_SIZE = (224, 224)

    FEATURE_DICT_INCLUDE_DEFAULT = {'姿态特征': ['侧卧', "伏卧", '犬卧', '站立', '蜷卧', '弓背', '角弓反张', '姿态不确定'],
                                    '出血特征': ['出血', '未出血', '出血不确定'],
                                    '颜色特征': ['泛红', '发紫', '发白', '潮红', '颜色正常', '颜色不确定'],
                                    '密度特征': ['扎堆', '未扎堆', '扎堆不确定']}


    FEATURE_LABEL_COUNT = {'pose': len(FEATURE_DICT_INCLUDE_DEFAULT['姿态特征']),
                           'bleed': len(FEATURE_DICT_INCLUDE_DEFAULT['出血特征']),
                           'color': len(FEATURE_DICT_INCLUDE_DEFAULT['颜色特征']),
                           'density': len(FEATURE_DICT_INCLUDE_DEFAULT['密度特征'])}

    FEATURE_CONVERT = {'姿态特征': 'pose', '出血特征': 'bleed', '颜色特征': 'color', '密度特征': 'density'}

    # 异常特征
    FEATURE_ANOMALOUS = {'犬卧', '伏卧', '蜷卧', '弓背', '角弓反张', '出血', '发紫', '发白', '潮红'}

    FEATURE_SHOW_THRESHOLD = .3


class Inference(object):
    def __init__(self, mask_model_weights, mask_config, mode="all", cls_model_weights=None, cls_config=None):
        """ 初始化推断模块
        param:
            mask_model_weights: mask模型权重
            mask_config: mask模型参数
            mode: 推断模式 all: mask + cls, mask: mask
            cls_model_weights: 分类模型权重
            cls_config: 分类模型参数
        """
        assert mode in ["all", "mask"], "mode should be all or mask"
        self.mask_model_weights = mask_model_weights
        self.mask_config = mask_config
        self.cls_model_weights = cls_model_weights
        self.cls_config = cls_config
        self.mode = mode
        if self.mode == "mask":
            self.maskmodel = self.build_model()
        else:
            self.maskmodel, self.clsmodel = self.build_model()

    def build_model(self):
        maskmodel = model_mask.MaskRCNN(mode="inference", config=self.mask_config)
        maskmodel.load_weights(self.mask_model_weights, by_name=True)
        if self.mode == "mask":
            return maskmodel
        else:
            clsmodel = model_classifier_mlabel.Classifier_mlabel(mode="inference", config=self.cls_config,
                                                                 weights_mode="pig", weights=self.cls_model_weights)
        return maskmodel, clsmodel

    def inference(self, image_path, splash_save_path=None, show=None, font_path=None, filter=False, only_weak=False):
        """
        param:
            image_path: 图片路径
            splash_save_path: 渲染图的保存路径，None则不保存
            show: 展示的信息, list格式, 限定于["class_id", "class_score", "box", "border", "mask", "fps", "rotate"]的子集
            font_path: 添加字体路径以满足对中文字体的支持
            filter: 对多modelmask的结果进行过滤
            only_weak: 图片渲染时只渲染病猪
        return:
            预测结果
        """
        image_test = io.imread(image_path)
        image_test = image_test[:, :, :3]
        res = self.maskmodel.detect([image_test], verbose=1)[0]
        if filter:
            del_list = self.if_overlap(res)
            if len(del_list) != 0:
                res = self.del_result(res, del_list)
        if self.mode == "all":
            scores = []
            image_list = rois_image(image_path, res['rois'], self.cls_config.CLASSIFIER_INPUT_SIZE)
            for image in image_list:
                score = self.clsmodel.detect([image])
                scores.append(score)
            res["fps"] = scores
        if splash_save_path:
            display_X(image_test, res, self.cls_config, show=show, font_path=font_path, save_path=splash_save_path,
                      only_weak=only_weak)
        res["fps"] = self.parse_fps(res['fps'], self.cls_config)
        res["masks"] = self.parse_masks(res["masks"])
        return res

    # 解析mask为坐标点
    def parse_masks(self, masks):
        res = []

        for mask in masks:
            print("mask: ", mask, type(mask))
            x, y = np.where(mask == 1)
            for i in range(len(x)):
                res.append([x[i], y[i]])
        return res

    # 解析fps用于接口返回
    def parse_fps(self, fps, config, only_weak=False):
        feature_label = list(config.FEATURE_DICT_INCLUDE_DEFAULT.values())
        res_stage1 = []
        for i in range(len(fps)):
            res_stage2 = []
            for j in range(len(feature_label)):
                loc = np.argmax(fps[i][j][0])
                feature = feature_label[j][loc]
                if only_weak:
                    if feature in config.FEATURE_ANOMALOUS:
                        res_stage2.append(feature + ": " + str(round(fps[i][j][0][loc], 4)))
                else:
                    res_stage2.append(feature + ": " + str(round(fps[i][j][0][loc], 4)))
            res_stage1.append(res_stage2)
        return res_stage1

    def if_overlap(self, result, rois_ratio=.6, mask_ratio=.4):
        """
        对预测结果中的rois和mask进行重叠率检测
        当前的删除原则是rois重叠率大于0.6且mask重叠率大于0.4
        """
        rois = result['rois']
        masks = result['masks']
        scores = result['scores']
        total_qty = len(scores)  # rows, cols, total_qty = masks.shape
        if total_qty == 1:
            return []
        del_list = []
        for i in range(total_qty - 1):
            if i in del_list:
                continue
            for j in range(i + 1, total_qty):
                if j in del_list:
                    continue
                # 计算roi重叠率
                b_y1, b_x1, b_y2, b_x2 = rois[i, :]
                a_y1, a_x1, a_y2, a_x2 = rois[j, :]
                inter = max(min(a_x2, b_x2) - max(a_x1, b_x1), 0) * max(min(a_y2, b_y2) - max(a_y1, b_y1), 0)
                roi_overlap_ratio = inter/min((b_y2-b_y1) * (b_x2-b_x1), (a_y2-a_y1)*(a_x2-a_x1))

                # 计算mask重叠率
                if roi_overlap_ratio > rois_ratio:
                    mask_overlap_pix = np.sum(np.multiply(masks[:, :, j], masks[:, :, i]))
                    i_pix = np.sum(masks[:, :, i])
                    j_pix = np.sum(masks[:, :, j])
                    mask_overlap_ratio = mask_overlap_pix / min(i_pix, j_pix)
                    if mask_overlap_ratio > mask_ratio:
                        if scores[i] > scores[j]:
                            del_list.append(j)
                        else:
                            del_list.append(i)
        return del_list

    def del_result(self, r, del_list):
        """根据del_list删除部分结果"""
        r['rois'] = np.delete(r['rois'], del_list, axis=0)
        r['class_ids'] = np.delete(r['class_ids'], del_list, axis=0)
        r['scores'] = np.delete(r['scores'], del_list, axis=0)
        r['masks'] = np.delete(r['masks'], del_list, axis=2)
        return r

if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument("--mode", default="all", help="inference mode, should be \"all\" or \"mask\"")
    argparser.add_argument("--filter", default=True, type=bool, help="weather use iou filter")
    argparser.add_argument("--only_weak", default=True, type=bool, help="only show weak feature")
    args = argparser.parse_args()
    ROOT_DIR = os.path.abspath("../")
    test_image = os.path.join(ROOT_DIR, "assets/test3.jpg")
    mask_model_weights = os.path.join(ROOT_DIR, "logs/test/mask_rcnn_pig.h5")
    cls_model_weights = os.path.join(ROOT_DIR, "logs/test/resnet_pig.h5")
    save_path = os.path.join(ROOT_DIR, "assets/test_splash.jpg")
    font_path = os.path.join(ROOT_DIR, "assets/font/STHeiti Medium.ttc")
    show = ["mask", "fps"]
    mode = args.mode
    filter = args.filter
    only_weak = False

    worker = Inference(mask_model_weights=mask_model_weights, mask_config=InferenceMaskConfig(), mode=mode,
                       cls_model_weights=cls_model_weights, cls_config=InferenceClsConfig())
    res = worker.inference(test_image, splash_save_path=save_path, show=show,
                           font_path=font_path, filter=filter, only_weak=only_weak)
    print(res)
    print(type(res["masks"]))
    print(type(res["masks"][0]))

